# Project Conventions for AI-Assisted Development

Guidelines for using Claude Code and other AI coding assistants when developing full-stack Go websites.

---

## Project Overview

This project uses:

- **Backend**: Go 1.25
- **Templates**: templ
- **Styling**: Tailwind CSS
- **Database**: SQLite + goose + sqlc
- **Auth**: Clerk
- **Backups**: litestream
- **Deployment**: Fly.io or Railway

---

## Code Style

### Go Conventions

#### Follow standard Go style:

- Use `gofmt` for formatting
- Use `golint` for linting
- Follow [Effective Go](https://go.dev/doc/effective_go) guidelines

#### Naming:

- Packages: lowercase, single word (`handlers`, `database`)
- Exported: PascalCase (`GetUser`, `CreateProfile`)
- Unexported: camelCase (`processRequest`, `validateInput`)
- Constants: PascalCase or ALL_CAPS for exported

#### Error Handling:

```go
// Preferred: explicit error handling
result, err := doSomething()
if err != nil {
    return fmt.Errorf("doing something: %w", err)
}

// Avoid: ignoring errors
result, _ := doSomething()  // Don't do this
```

#### Comments:

- Public functions: doc comments (complete sentences)
- Exported types: explain purpose
- Complex logic: inline comments

```go
// GetUser retrieves a user by ID from the database.
// Returns ErrNotFound if user doesn't exist.
func GetUser(ctx context.Context, id int64) (*User, error) {
    // Implementation
}
```

---

## Project Structure

```text
my-website/
├── main.go                 # Application entry point
├── go.mod                  # Go module definition
├── go.sum                  # Dependency checksums
├── .env                    # Environment variables (gitignored)
├── .gitignore              # Git ignore rules
│
├── handlers/               # HTTP handlers
│   ├── home.go
│   ├── auth.go
│   └── profile.go
│
├── middleware/             # HTTP middleware
│   ├── auth.go
│   └── logging.go
│
├── db/                     # Database files
│   ├── database.db         # SQLite file (gitignored)
│   ├── db.go               # Generated by sqlc
│   ├── models.go           # Generated by sqlc
│   ├── querier.go          # Generated by sqlc
│   │
│   ├── migrations/         # goose migrations
│   │   ├── 00001_init.sql
│   │   └── 00002_add_users.sql
│   │
│   └── queries/            # SQL queries for sqlc
│       ├── users.sql
│       └── profiles.sql
│
├── templates/              # templ templates
│   ├── layout.templ
│   ├── home.templ
│   ├── auth/
│   │   ├── login.templ
│   │   └── signup.templ
│   └── components/
│       ├── button.templ
│       └── card.templ
│
├── static/                 # Static assets
│   ├── styles.css          # Compiled Tailwind
│   ├── input.css           # Tailwind source
│   └── images/
│
├── config/                 # Configuration
│   └── config.go
│
├── litestream.yml          # Litestream backup config
├── sqlc.yaml               # sqlc configuration
└── tailwind.config.js      # Tailwind configuration
```

---

## File Naming

- Go files: `lowercase_with_underscores.go` or `camelCase.go`
- templ files: `lowercase.templ`
- SQL migrations: `NNNNN_descriptive_name.sql`
- SQL queries: `table_name.sql`

---

## Database Conventions

### Migrations (goose)

#### File naming:

```text
00001_create_users.sql
00002_add_profiles.sql
00003_add_index_users_email.sql
```

#### Migration structure:

```sql
-- +goose Up
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);

-- +goose Down
DROP INDEX idx_users_email;
DROP TABLE users;
```

#### Best practices:

- Always include both Up and Down
- One table or change per migration
- Test down migration before committing

### Queries (sqlc)

**File naming:** `table_name.sql`

#### Query naming pattern:

```sql
-- name: GetUser :one
-- name: ListUsers :many
-- name: CreateUser :one
-- name: UpdateUser :exec
-- name: DeleteUser :exec
```

#### Patterns:

- `Get*` - single record (`:one`)
- `List*` - multiple records (`:many`)
- `Create*` - insert (`:one` with RETURNING)
- `Update*` - update (`:exec`)
- `Delete*` - delete (`:exec`)

---

## templ Templates

### Component Structure

```templ
package templates

import "mywebsite/db"

// Layout wraps all pages
templ Layout(title string) {
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>{ title }</title>
        <link rel="stylesheet" href="/static/styles.css"/>
    </head>
    <body>
        @Header()
        <main>
            { children... }
        </main>
        @Footer()
    </body>
    </html>
}

// HomePage renders the home page
templ HomePage(user *db.User) {
    @Layout("Home") {
        <h1>Welcome, { user.Name }!</h1>
    }
}
```

### templ Best Practices

- One component per concern
- Pass data as parameters (typed!)
- Use composition (`@ComponentName()`)
- Leverage `children...` for layouts
- Keep logic in Go handlers, not templates

---

## Tailwind CSS

### Class Organization

#### Use consistent order:

```html
<!-- Layout → Sizing → Spacing → Typography → Colors → Effects → States -->
<div class="flex items-center justify-between w-full px-4 py-2 text-lg font-bold text-white bg-blue-500 rounded hover:bg-blue-600">
```

### Responsive Design

#### Mobile-first approach:

```html
<!-- Base (mobile), then md (tablet), then lg (desktop) -->
<div class="w-full md:w-1/2 lg:w-1/3">
```

### Custom Configuration

#### In `tailwind.config.js`:

```javascript
module.exports = {
  content: [
    "./templates/**/*.templ",
    "./templates/**/*.go",
  ],
  theme: {
    extend: {
      colors: {
        'brand': '#your-color',
      },
    },
  },
}
```

---

## Handlers Pattern

### Standard Handler Structure

```go
package handlers

import (
    "net/http"
    "mywebsite/db"
    "mywebsite/templates"
)

type App struct {
    db      *sql.DB
    queries *db.Queries
}

func (app *App) homeHandler(w http.ResponseWriter, r *http.Request) {
    // 1. Get data from database
    users, err := app.queries.ListUsers(r.Context())
    if err != nil {
        http.Error(w, "Database error", http.StatusInternalServerError)
        return
    }

    // 2. Render template
    templates.HomePage(users).Render(r.Context(), w)
}
```

### Form Handling

```go
func (app *App) createUserHandler(w http.ResponseWriter, r *http.Request) {
    // Parse form
    if err := r.ParseForm(); err != nil {
        http.Error(w, "Invalid form", http.StatusBadRequest)
        return
    }

    // Get values
    email := r.FormValue("email")
    name := r.FormValue("name")

    // Validate
    if email == "" || name == "" {
        http.Error(w, "Missing required fields", http.StatusBadRequest)
        return
    }

    // Create in database
    user, err := app.queries.CreateUser(r.Context(), db.CreateUserParams{
        Email: email,
        Name:  name,
    })
    if err != nil {
        http.Error(w, "Database error", http.StatusInternalServerError)
        return
    }

    // Redirect or respond
    http.Redirect(w, r, "/users/"+fmt.Sprint(user.ID), http.StatusSeeOther)
}
```

---

## Authentication with Clerk

### Middleware Pattern

```go
import (
    "github.com/clerk/clerk-sdk-go/v2"
    clerkhttp "github.com/clerk/clerk-sdk-go/v2/http"
)

func RequireAuth(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        claims, ok := clerk.SessionClaimsFromContext(r.Context())
        if !ok {
            http.Redirect(w, r, "/login", http.StatusSeeOther)
            return
        }
        next.ServeHTTP(w, r)
    }
}

// Usage:
http.HandleFunc("/dashboard", RequireAuth(app.dashboardHandler))
```

### Getting User Info

```go
func (app *App) protectedHandler(w http.ResponseWriter, r *http.Request) {
    // Get Clerk user ID
    claims, _ := clerk.SessionClaimsFromContext(r.Context())
    clerkUserID := claims.Subject

    // Get or create profile in your database
    profile, err := app.queries.GetProfileByClerkID(r.Context(), clerkUserID)
    if err != nil {
        // Create new profile
        profile, _ = app.queries.CreateProfile(r.Context(), db.CreateProfileParams{
            ClerkUserID: clerkUserID,
            Email:       claims.Email,
        })
    }

    // Use profile
    templates.Dashboard(profile).Render(r.Context(), w)
}
```

---

## Environment Variables

### Required Variables

```bash
# Database
DATABASE_PATH=./db/database.db

# Clerk Authentication
CLERK_PUBLISHABLE_KEY=pk_test_xxxxx
CLERK_SECRET_KEY=sk_test_xxxxx

# litestream Backups
LITESTREAM_ACCESS_KEY_ID=xxxxx
LITESTREAM_SECRET_ACCESS_KEY=xxxxx

# Server
PORT=8080
```

### Loading in Code

```go
import (
    "os"
    "github.com/joho/godotenv"
)

func main() {
    // Load .env file (development only)
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found")
    }

    // Access variables
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
}
```

---

## Git Workflow

### .gitignore

```gitignore
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
main

# Database
*.db
*.db-shm
*.db-wal

# Environment
.env
.env.local

# Generated files
*_templ.go
static/styles.css

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
```

### Commit Messages

**Format:** `type(scope): description`

#### Types:

- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation
- `style`: Formatting
- `refactor`: Code refactoring
- `test`: Adding tests
- `chore`: Maintenance

#### Examples:

```text
feat(auth): add Clerk authentication
fix(database): resolve connection pooling issue
docs(readme): update installation instructions
```

---

## Development Workflow

### Daily Development

```bash
# Terminal 1: Watch and regenerate templ files
templ generate --watch

# Terminal 2: Watch and rebuild Tailwind CSS
tailwindcss -i ./static/input.css -o ./static/styles.css --watch

# Terminal 3: Run application
go run main.go

# Terminal 4: Run litestream (if testing backups)
litestream replicate -config litestream.yml
```

### Before Committing

```bash
# Format Go code
go fmt ./...

# Run linter
golangci-lint run

# Run tests
go test ./...

# Generate templ
templ generate

# Build Tailwind
tailwindcss -i ./static/input.css -o ./static/styles.css --minify

# Run migrations
goose -dir db/migrations sqlite3 ./db/database.db up

# Generate sqlc code
sqlc generate

# Test build
go build -o main .
```

---

## Testing

### Unit Tests

```go
package handlers_test

import (
    "testing"
    "net/http/httptest"
)

func TestHomeHandler(t *testing.T) {
    app := &App{} // Initialize with test database

    req := httptest.NewRequest("GET", "/", nil)
    w := httptest.NewRecorder()

    app.homeHandler(w, req)

    if w.Code != 200 {
        t.Errorf("Expected status 200, got %d", w.Code)
    }
}
```

### Integration Tests

#### Use separate test database:

```go
func setupTestDB(t *testing.T) *sql.DB {
    db, err := sql.Open("sqlite3", ":memory:")
    if err != nil {
        t.Fatal(err)
    }

    // Run migrations
    // Add test data

    return db
}
```

---

## AI Assistant Guidelines

When using Claude Code or other AI assistants:

### DO

- ✅ Ask for explanations of generated code
- ✅ Request adherence to these conventions
- ✅ Ask for tests alongside code
- ✅ Request error handling
- ✅ Ask about performance implications

### DON'T

- ❌ Accept code without understanding
- ❌ Skip testing AI-generated code
- ❌ Ignore security considerations
- ❌ Commit generated code without review

### Good Prompts

#### Specific:

```text
Create a handler that lists all users from the database
using sqlc-generated queries and renders them with a templ template
```

#### With context:

```text
Following the project conventions in CLAUDE.md, create an
authentication middleware using Clerk that protects routes
```

#### Requesting explanation:

```text
Explain how the sqlc-generated code works and why we use
this pattern instead of raw SQL
```

---

## Production Considerations

### Before Deploying

- [ ] All environment variables set in platform
- [ ] Database migrations tested
- [ ] litestream configured and tested
- [ ] SSL certificate configured (automatic with Fly.io/Railway)
- [ ] Error handling in all handlers
- [ ] Logging configured
- [ ] Health check endpoint working

### Health Check

```go
func healthHandler(w http.ResponseWriter, r *http.Request) {
    // Check database
    if err := db.Ping(); err != nil {
        w.WriteHeader(http.StatusServiceUnavailable)
        fmt.Fprintf(w, "Database unavailable")
        return
    }

    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, "OK")
}
```

---

## Common Patterns

### Pagination

```go
func (app *App) listItemsHandler(w http.ResponseWriter, r *http.Request) {
    page := 1
    if p := r.URL.Query().Get("page"); p != "" {
        page, _ = strconv.Atoi(p)
    }

    limit := 20
    offset := (page - 1) * limit

    items, err := app.queries.ListItemsPaginated(r.Context(), db.ListItemsPaginatedParams{
        Limit:  int64(limit),
        Offset: int64(offset),
    })
    // ...
}
```

### Flash Messages

```go
// Set flash message
http.SetCookie(w, &http.Cookie{
    Name:     "flash",
    Value:    "Profile updated successfully",
    MaxAge:   1,
    Path:     "/",
    HttpOnly: true,
})

// Read flash message
func getFlash(r *http.Request) string {
    cookie, err := r.Cookie("flash")
    if err != nil {
        return ""
    }
    return cookie.Value
}
```

---

## Resources

- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments) - Go style guide
- [Effective Go](https://go.dev/doc/effective_go) - Official best practices
- [templ Documentation](https://templ.guide/) - templ guide
- [sqlc Documentation](https://docs.sqlc.dev/) - sqlc reference

---

## Summary

Follow these conventions for:

- ✅ Consistent code style
- ✅ Maintainable projects
- ✅ Easier collaboration
- ✅ Better AI assistance
- ✅ Production readiness

**Remember:** Conventions are guidelines, not strict rules. Adapt as your project evolves, but document changes!
